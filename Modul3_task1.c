/* Программа, осуществляющая двустороннюю поочередную связь процесса-родителя 
и процесса-ребенка через pipe, используя для синхронизации семафоры*/
#include <sys/types.h>
#include <unistd.h>
#include <sys/sem.h>
#include <stdio.h>

int main(){

int fd[2], fd2[2], result;
int semid; /* IPC дескриптор для массива IPC семафоров */
char pathname[] = "myfile"; /* Имя файла, использующееся для генерации ключа. Файл с таким именем должен существовать в текущей директории */
key_t key; /* IPC ключ */
struct sembuf mybuf; /* Структура для задания операции над семафором */

size_t size;
char resstring[14];

/* Генерируем IPC ключ из имени файла 08-1a.c в текущей директории
и номера экземпляра области разделяемой памяти 0 */
if((key = ftok(pathname,0)) < 0)
{
	printf("Can\'t generate key\n");
	exit(-1);
}

/* Пытаемся получить доступ по ключу к массиву семафоров, если он существует,
или создать его из одного семафора, если он еще не существует, с правами доступа
read & write для всех пользователей */
if((semid = semget(key, 1, 0666 | IPC_CREAT)) < 0)
{
	printf("Can\'t get semid\n");
	exit(-1);
}


/* Попытаемся создать pipe */
if(pipe(fd) < 0)
{
	/* Если создать pipe не удалось, печатаем об этом сообщение и прекращаем работу */
	printf("Can\'t create pipe1\n");
	exit(-1);
}
if(pipe(fd2) < 0)
{

	/* Если создать pipe не удалось, печатаем об этом сообщение и прекращаем работу */

	printf("Can\'t create pipe2\n");
	exit(-1);
}

/* Порождаем новый процесс */

result = fork();

if(result <0)
{

	/* Если создать процесс не удалось, сообщаем об этом и завершаем работу */

	printf("Can\'t fork child\n");
	exit(-1);

} 
else if (result > 0) 
{

	/* Мы находимся в родительском процессе, который будет передавать информацию процессу-ребенку . В этом процессе выходной поток данных нам не понадобится, поэтому закрываем его.*/

	close(fd[0]);

	/* Пробуем записать в pipe 14 байт, т.е. всю строку "Hello, world!"
	вместе с признаком конца строки */
	size = write(fd[1], "Hello, world!", 14);

	if(size != 14)
	{

		/* Если записалось меньшее количество байт, сообщаем об ошибке и завершаем работу */

		printf("Can\'t write all string\n");
		exit(-1);
	}

	/* Закрываем входной поток данных и на этом родитель прекращает работу */

	close(fd[1]);

	/* Выполним операцию D(semid1,1) для нашего массива семафоров.
	Для этого сначала заполним нашу структуру. Флаг, как обычно, полагаем равным 0.
	Наш массив семафоров состоит из одного семафора с номером 0. Код операции -1.*/

	mybuf.sem_op = -1;
	mybuf.sem_flg = 0;
	mybuf.sem_num = 0;

	if(semop(semid, &mybuf, 1) < 0)
	{
	printf("Can\'t wait for condition\n");
	exit(-1);
	}

	/* Мы находимся в порожденном процессе, который будет получать информацию от процесса-родителя. Он унаследовал от родителя таблицу открытых файлов и, зная файловые дескрипторы, соответствующие pip'у, может его использовать. В этом процессе входной поток данных нам не понадобится, поэтому закрываем его.*/
	close(fd2[1]);

	/* Пробуем прочитать из pip'а 14 байт в массив, т.е. всю записанную строку */
	size = read(fd2[0], resstring, 14);

	if(size < 0)
	{
		/* Если прочитать не смогли, сообщаем об ошибке и завершаем работу */
		printf("Can\'t read string\n");
		exit(-1);
	}

	/* Печатаем прочитанную строку */
	printf("%s\n",resstring);

	/* Закрываем входной поток и завершаем работу */
	close(fd2[0]);

	printf("Parent exit\n");

} 
else 
{

	/* Мы находимся в порожденном процессе, который будет получать информацию от процесса-родителя. Он унаследовал от родителя таблицу открытых файлов и, зная файловые дескрипторы, соответствующие pip'у, может его использовать. В этом процессе входной поток данных нам не понадобится, поэтому закрываем его.*/

	close(fd[1]);

	/* Пробуем прочитать из pip'а 14 байт в массив, т.е. всю записанную строку */

	size = read(fd[0], resstring, 14);

	if(size < 0)
	{

		/* Если прочитать не смогли, сообщаем об ошибке и завершаем работу */

		printf("Can\'t read string\n");
		exit(-1);
	}

	/* Печатаем прочитанную строку */
	printf("%s\n",resstring);

	/* Закрываем входной поток и завершаем работу */
	close(fd[0]);

	close(fd2[0]);

	/* Пробуем записать в pipe 14 байт, т.е. всю строку "Hello, world!"
	вместе с признаком конца строки */
	size = write(fd2[1], "Hello, wood!!", 14);

	if(size != 14)
	{

		/* Если записалось меньшее количество байт, сообщаем об ошибке и завершаем работу */

		printf("Can\'t write all string\n");
		exit(-1);
	}

	/* Закрываем входной поток данных и на этом родитель прекращает работу */

	close(fd2[1]);
	/* Выполним операцию A(semid1,1) для нашего массива семафоров.
	Для этого сначала заполним нашу структуру. Флаг, как обычно, полагаем равным 0.
	Наш массив семафоров состоит из одного семафора с номером 0. Код операции 1.*/

	mybuf.sem_op = 1;
	mybuf.sem_flg = 0;
	mybuf.sem_num = 0;

	if(semop(semid, &mybuf, 1) < 0)
	{
		printf("Can\'t wait for condition\n");
		exit(-1);
	}

	printf("Child exit\n");

}

return 0;
}
